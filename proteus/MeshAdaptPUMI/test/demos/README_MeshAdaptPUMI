To use SCOREC tools, we must modify the case files slightly.
Notation-wise, PUMI is the general software package that houses MeshAdapt and is part of the SCOREC open-source libraries.
The following is a list of necessary lines/options in the various case file inputs.

<casename>.py

1. We need to import the MeshAdaptPUMI functionality
  from proteus.MeshAdaptPUMI import MeshAdaptPUMI 

2. We need to have the archives gather at the conclusion of a parallel simulation.
  gatherAtClose=True

3. We need to have only one level in the multilevel mesh implementation
  nLevels = 1

4. By default, proteus partitions the mesh by nodes whereas PUMI partitions the mesh by elements.
  parallelPartitioningType = proteus.MeshTools.MeshParallelPartitioningTypes.element
  nLayersOfOverlapForParallel = 0

5. The PUMI domain requires a list of model face tags that correspond to the boundary tags that are provided.
  domain.faceList=[[3],[5],[1],[6],[2],[4]]

If the boundary tags were in the order of ['bottom','top','left', ...] then [3],[5],[1] are supposed to be the corresponding model faces, respectively.
In converting a GMSH case to a SCOREC-GMSH case, one has to be careful because of the use of "Physical Entities".
Standard GMSH and Proteus allows the grouping of geometric entities under "Physical Entities" that are not translated when converting to a SCOREC model/mesh.
Always use the true model surface tags when listing faces for PUMI.

6. There are many options that can be supplied to MeshAdapt and they are as follows ([] contains default value):  

   a) adaptMesh = [] True/False (Turn on/off MeshAdapt functionality)
   b) adaptMesh_nSteps = [] 10  (How often do you want to check the error and possibly adapt? The example here means after 10 timesteps)
   c) hmin, hmax [100,1e-8] (minimum and maximum element diameters in meters) 
   c) numIter = [10] (How many iterations of adaptation should MeshAdapt go through? More iterations yield a mesh closer to the designated size field)
   d) sfConfig = ["ERM"] (How do you want the size field to be generated? Currently, only a size field generated by an error estimator is actively supported. Some tests use "isotropic" to perform uniform refinement based on the minimum element diameter.)
   e) maType = ["isotropic"]/"anisotropic" (Should the adaptation be isotropic or anisotropic for the "ERM" size field? Currently only "isotropic" is actively supported.)
   e) logConfig = "on"/["off"]/"errorOnly" (Do you want to save the preadapt and postadapt meshes/solution for comparison? "errorOnly" only records the preAdapt mesh with solution and error fields and should not trigger adaptation) 
   f) targetError = [0] (What is the target error for each element in the mesh? 0 means generate the size field based on the current total error.) 
   g) targetElementCount = [0] (What is the desired total number of elements in the mesh? 0 means avoid scaling the size field to achieve any target number)

Most of these options are passed in through the constructor: 
domain.PUMIMesh=MeshAdaptPUMI.MeshAdaptPUMI(hmax, hmin, numIter,sfConfig,maType,logConfig,targetError,targetElementCount)

7. Finally, we load the model and mesh:
  domain.PUMIMesh.loadModelAndMesh(<modelname.dmg>, <meshname.smb>)

Note that the mesh name should not include the integer that's appended to it.

<casename>_so.py

1. Again, we need to import the MeshAdaptPUMI libraries:
  from proteus import MeshAdaptPUMI
2. To avoid errors during the archiving stage, we use the following flag:
  archiveFlag = ArchiveFlags.EVERY_SEQUENCE_STEP / ArchiveFlags.EVERY_USER_STEP
